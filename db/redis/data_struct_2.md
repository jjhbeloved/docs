# data struct 2

## 1. intset 整数集合

当一个集合**只**包含**整数值元素**， `并且`这个集合的**元素数量不多**时， Redis 就会使用整数集合作为集合键的底层实现

``` c++
typedef struct intset {
    // 编码方式
    uint32_t encoding;

    // 集合包含的元素数量
    uint32_t length;

    // 保存元素的数组
    int8_t contents[];
} intset;
```

- 如果 encoding 属性的值为 `INTSET_ENC_INT16` ， 那么 contents 就是一个 int16_t 类型的数组， 数组里的每个项都是一个 `int16_t` 类型的整数值 （最小值为 -32,768 ，最大值为 32,767 ）。
- 如果 encoding 属性的值为 `INTSET_ENC_INT32` ， 那么 contents 就是一个 int32_t 类型的数组， 数组里的每个项都是一个 `int32`_t 类型的整数值 （最小值为 -2,147,483,648 ，最大值为 2,147,483,647 ）。
- 如果 encoding 属性的值为 `INTSET_ENC_INT64` ， 那么 contents 就是一个 int64_t 类型的数组， 数组里的每个项都是一个 `int64_t` 类型的整数值 （最小值为 -9,223,372,036,854,775,808 ，最大值为 9,223,372,036,854,775,807 ）

`contents 数组`是整数集合的底层实现： 整数集合的每个元素都是 contents 数组的一个数组项（item）， 各个项在数组中按值的大小**从小到大**有序地排列， 并且数组中不包含任何重复项

contents 的实际数值类型, 是根据 encoding 决定的, 而数组类型是按照数组中最大的 数值类型 决定的, 可以从 uint16 升级到 uint64, 但是**不能降级**.

### 升级

1. 根据新元素的类型， 扩展整数集合底层数组的空间大小， 并为新元素分配空间。
2. 将底层数组现有的所有元素都转换成与新元素相同的类型， 并将类型转换后的元素放置到正确的位上， 而且在放置元素的过程中， 需要继续维持底层数组的有序性质不变。
3. 将新元素添加到底层数组里面

向整数集合添加新元素的时间复杂度为`O(N)` 

> 引发升级的新元素的长度总是比整数集合现有所有元素的长度都大， 所以这个新元素的值要么就大于所有现有元素， 要么就小于所有现有元素：
>
> - 在新元素小于所有现有元素的情况下， 新元素会被放置在底层数组的最开头（索引 0 ）
> - 在新元素大于所有现有元素的情况下， 新元素会被放置在底层数组的最末尾（索引 length-1 ）

### 升级的好处

1. 提升灵活性, 不用关心插入的数据的类型
2. 节约内存, 不需要为了预留未来某些极小出现uint64的可能, 而占用一片连续大内存

## 2. ziplist 压缩列表

为节约内存而开发的**顺序型**数据结构

**列表键**只包含**少量**列表项， `并且`每个列表项要么就是**小整数值**， 要么就是长度**比较短的字符串**， 那么 Redis 就会使用压缩列表来做列表键的底层实现

### 压缩列表结构

``` c++
typedef struct ziplist {
    // 记录整个压缩列表占用的内存字节数：在对压缩列表进行内存重分配， 或者计算 zlend 的位置时使用。
    uint32_t zlbytes;
    // 记录压缩列表表尾节点距离压缩列表的起始地址有多少字节: 通过这个偏移量，程序无须遍历整个压缩列表就可以确定表尾节点的地址。
    uint32_t zltail;
    // 记录了压缩列表包含的节点数量： 当这个属性的值小于 UINT16_MAX （65535）时， 这个属性的值就是压缩列表包含节点的数量； 当这个值等于 UINT16_MAX 时， 节点的真实数量需要遍历整个压缩列表才能计算得出。
    uint16_t zllen;
    // 压缩列表包含的各个节点，节点的长度由节点保存的内容决定
    listNode entryX[];
    // 特殊值 0xFF （十进制 255 ），用于标记压缩列表的末端
    uint8_t zlend;
} ziplist;
```

![压缩列表](./imgs/ziplist_data_struct.png)

### 压缩列表节点结构

每个压缩列表节点可以保存一个**字节数组**`或者`一个**整数值**

字符数组:

1. 长度小于等于 `63 （2^{6}-1）`字节的字节数组
2. 长度小于等于 `16383 （2^{14}-1）`字节的字节数组
3. 长度小于等于 `4294967295 （2^{32}-1）`字节的字节数组

整数值:

1. `4 bit`，介于 0 至 12 之间的无符号整数；
2. `1 byte`长的**有符号**整数；
3. `3 byte`长的**有符号**整数；
4. `int16_t` 类型整数；
5. `int32_t` 类型整数；
6. `int64_t` 类型整数。

![压缩列表节点](./imgs/ziplist_node_data_struct.png)

- **previous_entry_length**: 以字节为单位， 记录了压缩列表中**前一个**节点的长度
  1. 如果前一节点的长度**小于 254 字节**， 那么 previous_entry_length 属性的长度为 `1 byte`
  2. 如果前一节点的长度**大于等于 254 字节**， 那么 previous_entry_length 属性的长度为 `5 byte`: 第一字节会被设置为 0xFE （十进制值 254）， 而之后的四个字节则用于保存前一节点的长度
- **encoding**: 属性记录了节点的 content 属性所保存**数据的类型**以及**长度**
  1. 1 byte、2 byte 或者5 byte， 值的**最高位**为 `00` 、 `01` 或者 `10` 的是**字节数组编码**
  2. 1 byte **最高位**以 `11` 开头的是**整数编码**, **长度**由编码除去最高两位之后的其他位记录(其实更是标志了 实际使用的整数类型, 整数类型表明了长度)
- **content**: 属性负责保存节点的值， 节点值可以是一个字节数组或者整数

### 连锁更新

当存在有**多个连续的、长度介于 250 字节至 253 字节之间**的节点, 将新值(长度超过254)插入这个对象的之前, 连锁更新才有可能被引发, 因为后续的节点都要扩容, 扩容异味着要重新分配内存空间

ziplistPush(创建一个包含给定值的新节点， 并将这个新节点添加到压缩列表的**表头**或者表尾) 等命令的平均复杂度仅为 O(N) , 连锁更新的最坏复杂度为 O(N^2)

## 3. quicklist 快速列表
