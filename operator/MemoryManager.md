# memory manager

**虚拟内存**采用的是**分页**技术.

1 PAGE = 4096 = 4 KB 大小

页表就是一个页表条目（Page Table Entry,PTE）的数组。页表条目就包括：哪一页，是否在内存，虚拟内存中的地址，在内存中的地址，在外存中的地址这类信息。下面是我们之前使用的页表。

## 分页系统地址映射

每**页的大小是固定的**.

**内存管理单元（MMU）**管理着地址空间和物理内存的转换，其中的`页表`（Page table）存储着`页`（程序地址空间）和`页框`（物理内存空间）的**映射表**。

一个虚拟地址分成两个部分，一部分存储页面号，一部分存储偏移量。

> 虚拟地址 = 页号 page no + 偏移量 offset

## 页面置换算法

如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。

### 最佳 OPT, Optimal replacement algorithm

所选择的被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率。

是一种理论上的算法，因为无法知道一个页面多长时间不再被访问

### 最近最久未使用 LRU, Least Recently Used

因为每次访问都需要更新链表，因此这种方式实现的 LRU 代价很高。

可以简单的使用 LinkedList 链表, 扩展 removeAfter 和 insertAfter 方法, 在每次更新后, 会将被更新的值放至到链表的 last point.

### 最近未使用 NRU, Not Recently Used

每个页面都有两个状态位：R 与 M，当页面被访问时设置页面的 R=1，当页面被修改时设置 M=1。其中 R 位会**定时被清零**

NRU 优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0）

### 先进先出 FIFO, First In First Out

将那些经常被访问的页面也被换出，从而使缺页率升高

用一个 QUEUE 就可以实现

### 第二次机会算法

当页面被访问 (读或写) 时设置该页面的 R 位为 1。需要替换的时候，检查最老页面的 R 位。如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是 1，就将 R 位清 0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索

需要在链表中移动页面，降低了效率

### 时钟 Clock

时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面

## 分段

每页内部可以由多段构成, 每个段的大小是不固定的

## 段页式

对程序员的透明性：分页透明，但是分段需要程序员显式划分每个段。

地址空间的维度：分页是一维地址空间，分段是二维的。

大小是否可以改变：页的大小不可变，段的大小可以动态改变。

出现的原因：**分页**主要用于实现虚拟内存，从而获得**更大的地址空间**；**分段**主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且**有助于共享和保护**